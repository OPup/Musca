-- ----------------------------------------------------------------------
--  HLS HDL:        VHDL Netlister
--  HLS Version:    2011a.126 Production Release
--  HLS Date:       Wed Aug  8 00:52:07 PDT 2012
-- 
--  Generated by:   kjr115@EEWS104A-006
--  Generated date: Fri May 06 17:29:58 2016
-- ----------------------------------------------------------------------

-- 
-- ------------------------------------------------------------------
--  Design Unit:    Counter_core_fsm
--  FSM Module
-- ------------------------------------------------------------------

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_ARITH.ALL;
LIBRARY mgc_hls;
USE mgc_hls.funcs.ALL;
USE work.Counter_mux_pkg.ALL;


ENTITY Counter_core_fsm IS
  PORT(
    clk : IN STD_LOGIC;
    en : IN STD_LOGIC;
    asyn_rst : IN STD_LOGIC;
    fsm_output : OUT STD_LOGIC_VECTOR (2 DOWNTO 0);
    st_for_for_tr0 : IN STD_LOGIC;
    st_for_tr0 : IN STD_LOGIC
  );
END Counter_core_fsm;

ARCHITECTURE v4 OF Counter_core_fsm IS
  -- Default Constants

  -- FSM State Type Declaration for Counter_core_fsm_1
  TYPE Counter_core_fsm_1_ST IS (st_main, st_for_for, st_for);

  SIGNAL state_var : Counter_core_fsm_1_ST;
  SIGNAL state_var_NS : Counter_core_fsm_1_ST;

BEGIN
  -- Default Constant Signal Assignments

  Counter_core_fsm_1 : PROCESS (st_for_for_tr0, st_for_tr0, state_var)
  BEGIN
    CASE state_var IS
      WHEN st_main =>
        fsm_output <= STD_LOGIC_VECTOR'("001");
        state_var_NS <= st_for_for;
      WHEN st_for_for =>
        fsm_output <= STD_LOGIC_VECTOR'("010");
        IF ( st_for_for_tr0 = '1' ) THEN
          state_var_NS <= st_for;
        ELSE
          state_var_NS <= st_for_for;
        END IF;
      WHEN st_for =>
        fsm_output <= STD_LOGIC_VECTOR'("100");
        IF ( st_for_tr0 = '1' ) THEN
          state_var_NS <= st_main;
        ELSE
          state_var_NS <= st_for_for;
        END IF;
      WHEN OTHERS =>
        fsm_output <= "000";
        state_var_NS <= st_main;
    END CASE;
  END PROCESS Counter_core_fsm_1;

  Counter_core_fsm_1_REG : PROCESS (clk, asyn_rst)
  BEGIN
    IF ( asyn_rst = '0' ) THEN
      state_var <= st_main;
    ELSIF clk'event AND ( clk = '1' ) THEN
      IF ( en = '1' ) THEN
        state_var <= state_var_NS;
      END IF;
    END IF;
  END PROCESS Counter_core_fsm_1_REG;

END v4;

-- ------------------------------------------------------------------
--  Design Unit:    Counter_core
-- ------------------------------------------------------------------

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_ARITH.ALL;
LIBRARY mgc_hls;
USE mgc_hls.funcs.ALL;
USE work.Counter_mux_pkg.ALL;


ENTITY Counter_core IS
  PORT(
    clk : IN STD_LOGIC;
    en : IN STD_LOGIC;
    asyn_rst : IN STD_LOGIC;
    row_count_rsc_mgc_out_stdreg_d : OUT STD_LOGIC_VECTOR (4 DOWNTO 0);
    col_count_rsc_mgc_out_stdreg_d : OUT STD_LOGIC_VECTOR (4 DOWNTO 0)
  );
END Counter_core;

ARCHITECTURE v4 OF Counter_core IS
  -- Default Constants

  -- Output Reader Declarations
  SIGNAL row_count_rsc_mgc_out_stdreg_d_drv : STD_LOGIC_VECTOR (4 DOWNTO 0);
  SIGNAL col_count_rsc_mgc_out_stdreg_d_drv : STD_LOGIC_VECTOR (4 DOWNTO 0);

  -- Interconnect Declarations
  SIGNAL fsm_output : STD_LOGIC_VECTOR (2 DOWNTO 0);
  SIGNAL for_i_1_sva_2 : STD_LOGIC_VECTOR (5 DOWNTO 0);
  SIGNAL for_for_j_1_sva_2 : STD_LOGIC_VECTOR (5 DOWNTO 0);
  SIGNAL and_1_cse : STD_LOGIC;
  SIGNAL z_out : STD_LOGIC_VECTOR (6 DOWNTO 0);
  SIGNAL nor_3_cse : STD_LOGIC;

  SIGNAL mux_6_nl : STD_LOGIC_VECTOR (5 DOWNTO 0);
  COMPONENT Counter_core_fsm
    PORT(
      clk : IN STD_LOGIC;
      en : IN STD_LOGIC;
      asyn_rst : IN STD_LOGIC;
      fsm_output : OUT STD_LOGIC_VECTOR (2 DOWNTO 0);
      st_for_for_tr0 : IN STD_LOGIC;
      st_for_tr0 : IN STD_LOGIC
    );
  END COMPONENT;
  SIGNAL Counter_core_fsm_inst_fsm_output : STD_LOGIC_VECTOR (2 DOWNTO 0);
  SIGNAL Counter_core_fsm_inst_st_for_for_tr0 : STD_LOGIC;
  SIGNAL Counter_core_fsm_inst_st_for_tr0 : STD_LOGIC;

BEGIN
  -- Default Constant Signal Assignments

  -- Output Reader Assignments
  row_count_rsc_mgc_out_stdreg_d <= row_count_rsc_mgc_out_stdreg_d_drv;
  col_count_rsc_mgc_out_stdreg_d <= col_count_rsc_mgc_out_stdreg_d_drv;

  Counter_core_fsm_inst : Counter_core_fsm
    PORT MAP(
      clk => clk,
      en => en,
      asyn_rst => asyn_rst,
      fsm_output => Counter_core_fsm_inst_fsm_output,
      st_for_for_tr0 => Counter_core_fsm_inst_st_for_for_tr0,
      st_for_tr0 => Counter_core_fsm_inst_st_for_tr0
    );
  fsm_output <= Counter_core_fsm_inst_fsm_output;
  Counter_core_fsm_inst_st_for_for_tr0 <= z_out(6);
  Counter_core_fsm_inst_st_for_tr0 <= z_out(6);

  and_1_cse <= (NOT((NOT((NOT (fsm_output(2))) OR (z_out(6)))) OR (fsm_output(0))))
      AND ((NOT (fsm_output(1))) OR (z_out(6)));
  nor_3_cse <= NOT((fsm_output(0)) OR (fsm_output(2)));
  PROCESS (clk, asyn_rst)
  BEGIN
    IF ( asyn_rst = '0' ) THEN
      col_count_rsc_mgc_out_stdreg_d_drv <= STD_LOGIC_VECTOR'("00000");
      row_count_rsc_mgc_out_stdreg_d_drv <= STD_LOGIC_VECTOR'("00000");
      for_i_1_sva_2 <= STD_LOGIC_VECTOR'("000000");
      for_for_j_1_sva_2 <= STD_LOGIC_VECTOR'("000000");
    ELSIF clk'EVENT AND ( clk = '1' ) THEN
      IF ( en = '1' ) THEN
        col_count_rsc_mgc_out_stdreg_d_drv <= MUX_v_5_2_2(((z_out(4 DOWNTO 0)) AND
            STD_LOGIC_VECTOR(CONV_SIGNED(CONV_SIGNED(fsm_output(1), 1),5))) & col_count_rsc_mgc_out_stdreg_d_drv,
            and_1_cse);
        row_count_rsc_mgc_out_stdreg_d_drv <= MUX_v_5_2_2(((MUX_v_5_2_2((z_out(4
            DOWNTO 0)) & (for_i_1_sva_2(4 DOWNTO 0)), nor_3_cse)) AND STD_LOGIC_VECTOR(CONV_SIGNED(CONV_SIGNED(NOT
            (fsm_output(0)), 1),5))) & row_count_rsc_mgc_out_stdreg_d_drv, and_1_cse);
        for_i_1_sva_2 <= (MUX_v_6_2_2((z_out(5 DOWNTO 0)) & for_i_1_sva_2, nor_3_cse))
            AND STD_LOGIC_VECTOR(CONV_SIGNED(CONV_SIGNED(NOT (fsm_output(0)), 1),6));
        for_for_j_1_sva_2 <= (z_out(5 DOWNTO 0)) AND STD_LOGIC_VECTOR(CONV_SIGNED(CONV_SIGNED(nor_3_cse,
            1),6));
      END IF;
    END IF;
  END PROCESS;
  mux_6_nl <= MUX_v_6_2_2(for_for_j_1_sva_2 & for_i_1_sva_2, fsm_output(2));
  z_out <= STD_LOGIC_VECTOR(CONV_UNSIGNED(CONV_UNSIGNED(UNSIGNED(mux_6_nl), 7) +
      UNSIGNED'("0000001"), 7));
END v4;

-- ------------------------------------------------------------------
--  Design Unit:    Counter
--  Generated from file(s):
--    5) $PROJECT_HOME/../../src/AccessCount.cpp
-- ------------------------------------------------------------------

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_ARITH.ALL;
LIBRARY mgc_hls;
USE mgc_hls.funcs.ALL;
USE work.Counter_mux_pkg.ALL;


ENTITY Counter IS
  PORT(
    row_count_rsc_z : OUT STD_LOGIC_VECTOR (4 DOWNTO 0);
    col_count_rsc_z : OUT STD_LOGIC_VECTOR (4 DOWNTO 0);
    clk : IN STD_LOGIC;
    en : IN STD_LOGIC;
    asyn_rst : IN STD_LOGIC
  );
END Counter;

ARCHITECTURE v4 OF Counter IS
  -- Default Constants

  -- Interconnect Declarations
  SIGNAL row_count_rsc_mgc_out_stdreg_d : STD_LOGIC_VECTOR (4 DOWNTO 0);
  SIGNAL col_count_rsc_mgc_out_stdreg_d : STD_LOGIC_VECTOR (4 DOWNTO 0);

  SIGNAL row_count_rsc_mgc_out_stdreg_d_1 : STD_LOGIC_VECTOR (4 DOWNTO 0);
  SIGNAL row_count_rsc_mgc_out_stdreg_z : STD_LOGIC_VECTOR (4 DOWNTO 0);

  SIGNAL col_count_rsc_mgc_out_stdreg_d_1 : STD_LOGIC_VECTOR (4 DOWNTO 0);
  SIGNAL col_count_rsc_mgc_out_stdreg_z : STD_LOGIC_VECTOR (4 DOWNTO 0);

  COMPONENT Counter_core
    PORT(
      clk : IN STD_LOGIC;
      en : IN STD_LOGIC;
      asyn_rst : IN STD_LOGIC;
      row_count_rsc_mgc_out_stdreg_d : OUT STD_LOGIC_VECTOR (4 DOWNTO 0);
      col_count_rsc_mgc_out_stdreg_d : OUT STD_LOGIC_VECTOR (4 DOWNTO 0)
    );
  END COMPONENT;
  SIGNAL Counter_core_inst_row_count_rsc_mgc_out_stdreg_d : STD_LOGIC_VECTOR (4 DOWNTO
      0);
  SIGNAL Counter_core_inst_col_count_rsc_mgc_out_stdreg_d : STD_LOGIC_VECTOR (4 DOWNTO
      0);

BEGIN
  -- Default Constant Signal Assignments

  row_count_rsc_mgc_out_stdreg : mgc_hls.mgc_ioport_comps.mgc_out_stdreg
    GENERIC MAP(
      rscid => 1,
      width => 5
      )
    PORT MAP(
      d => row_count_rsc_mgc_out_stdreg_d_1,
      z => row_count_rsc_mgc_out_stdreg_z
    );
  row_count_rsc_mgc_out_stdreg_d_1 <= row_count_rsc_mgc_out_stdreg_d;
  row_count_rsc_z <= row_count_rsc_mgc_out_stdreg_z;

  col_count_rsc_mgc_out_stdreg : mgc_hls.mgc_ioport_comps.mgc_out_stdreg
    GENERIC MAP(
      rscid => 2,
      width => 5
      )
    PORT MAP(
      d => col_count_rsc_mgc_out_stdreg_d_1,
      z => col_count_rsc_mgc_out_stdreg_z
    );
  col_count_rsc_mgc_out_stdreg_d_1 <= col_count_rsc_mgc_out_stdreg_d;
  col_count_rsc_z <= col_count_rsc_mgc_out_stdreg_z;

  Counter_core_inst : Counter_core
    PORT MAP(
      clk => clk,
      en => en,
      asyn_rst => asyn_rst,
      row_count_rsc_mgc_out_stdreg_d => Counter_core_inst_row_count_rsc_mgc_out_stdreg_d,
      col_count_rsc_mgc_out_stdreg_d => Counter_core_inst_col_count_rsc_mgc_out_stdreg_d
    );
  row_count_rsc_mgc_out_stdreg_d <= Counter_core_inst_row_count_rsc_mgc_out_stdreg_d;
  col_count_rsc_mgc_out_stdreg_d <= Counter_core_inst_col_count_rsc_mgc_out_stdreg_d;

END v4;



