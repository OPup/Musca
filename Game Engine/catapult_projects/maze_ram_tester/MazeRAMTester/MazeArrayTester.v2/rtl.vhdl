-- ----------------------------------------------------------------------
--  HLS HDL:        VHDL Netlister
--  HLS Version:    2011a.126 Production Release
--  HLS Date:       Wed Aug  8 00:52:07 PDT 2012
-- 
--  Generated by:   kjr115@EEWS104A-006
--  Generated date: Fri May 06 17:31:52 2016
-- ----------------------------------------------------------------------

-- 
-- ------------------------------------------------------------------
--  Design Unit:    MazeArrayTester_core_fsm
--  FSM Module
-- ------------------------------------------------------------------

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_ARITH.ALL;
LIBRARY mgc_hls;
USE mgc_hls.funcs.ALL;
USE work.MazeArrayTester_mux_pkg.ALL;


ENTITY MazeArrayTester_core_fsm IS
  PORT(
    clk : IN STD_LOGIC;
    rst : IN STD_LOGIC;
    fsm_output : OUT STD_LOGIC_VECTOR (4 DOWNTO 0);
    st_main_tr0 : IN STD_LOGIC;
    st_if_for_for_1_tr0 : IN STD_LOGIC;
    st_if_for_tr0 : IN STD_LOGIC
  );
END MazeArrayTester_core_fsm;

ARCHITECTURE v2 OF MazeArrayTester_core_fsm IS
  -- Default Constants

  -- FSM State Type Declaration for MazeArrayTester_core_fsm_1
  TYPE MazeArrayTester_core_fsm_1_ST IS (st_core_rlp, st_main, st_if_for_for, st_if_for_for_1,
      st_if_for);

  SIGNAL state_var : MazeArrayTester_core_fsm_1_ST;
  SIGNAL state_var_NS : MazeArrayTester_core_fsm_1_ST;

BEGIN
  -- Default Constant Signal Assignments

  MazeArrayTester_core_fsm_1 : PROCESS (st_main_tr0, st_if_for_for_1_tr0, st_if_for_tr0,
      state_var)
  BEGIN
    CASE state_var IS
      WHEN st_core_rlp =>
        fsm_output <= STD_LOGIC_VECTOR'("00001");
        state_var_NS <= st_main;
      WHEN st_main =>
        fsm_output <= STD_LOGIC_VECTOR'("00010");
        IF ( st_main_tr0 = '1' ) THEN
          state_var_NS <= st_main;
        ELSE
          state_var_NS <= st_if_for_for;
        END IF;
      WHEN st_if_for_for =>
        fsm_output <= STD_LOGIC_VECTOR'("00100");
        state_var_NS <= st_if_for_for_1;
      WHEN st_if_for_for_1 =>
        fsm_output <= STD_LOGIC_VECTOR'("01000");
        IF ( st_if_for_for_1_tr0 = '1' ) THEN
          state_var_NS <= st_if_for;
        ELSE
          state_var_NS <= st_if_for_for;
        END IF;
      WHEN st_if_for =>
        fsm_output <= STD_LOGIC_VECTOR'("10000");
        IF ( st_if_for_tr0 = '1' ) THEN
          state_var_NS <= st_main;
        ELSE
          state_var_NS <= st_if_for_for;
        END IF;
      WHEN OTHERS =>
        fsm_output <= "00000";
        state_var_NS <= st_core_rlp;
    END CASE;
  END PROCESS MazeArrayTester_core_fsm_1;

  MazeArrayTester_core_fsm_1_REG : PROCESS (clk)
  BEGIN
    IF clk'event AND ( clk = '1' ) THEN
      IF ( rst = '1' ) THEN
        state_var <= st_core_rlp;
      ELSE
        state_var <= state_var_NS;
      END IF;
    END IF;
  END PROCESS MazeArrayTester_core_fsm_1_REG;

END v2;

-- ------------------------------------------------------------------
--  Design Unit:    MazeArrayTester_core
-- ------------------------------------------------------------------

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_ARITH.ALL;
LIBRARY mgc_hls;
USE mgc_hls.funcs.ALL;
USE work.MazeArrayTester_mux_pkg.ALL;


ENTITY MazeArrayTester_core IS
  PORT(
    clk : IN STD_LOGIC;
    rst : IN STD_LOGIC;
    row_rsc_mgc_out_stdreg_d : OUT STD_LOGIC_VECTOR (5 DOWNTO 0);
    col_rsc_mgc_out_stdreg_d : OUT STD_LOGIC_VECTOR (5 DOWNTO 0);
    out_rsc_mgc_out_stdreg_d : OUT STD_LOGIC_VECTOR (3 DOWNTO 0);
    write_rsc_mgc_out_stdreg_d : OUT STD_LOGIC
  );
END MazeArrayTester_core;

ARCHITECTURE v2 OF MazeArrayTester_core IS
  -- Default Constants

  -- Output Reader Declarations
  SIGNAL row_rsc_mgc_out_stdreg_d_drv : STD_LOGIC_VECTOR (5 DOWNTO 0);
  SIGNAL col_rsc_mgc_out_stdreg_d_drv : STD_LOGIC_VECTOR (5 DOWNTO 0);
  SIGNAL out_rsc_mgc_out_stdreg_d_drv : STD_LOGIC_VECTOR (3 DOWNTO 0);
  SIGNAL write_rsc_mgc_out_stdreg_d_drv : STD_LOGIC;

  -- Interconnect Declarations
  SIGNAL fsm_output : STD_LOGIC_VECTOR (4 DOWNTO 0);
  SIGNAL and_dcpl_4 : STD_LOGIC;
  SIGNAL and_dcpl_5 : STD_LOGIC;
  SIGNAL written_sva : STD_LOGIC;
  SIGNAL if_for_for_j_1_sva_1 : STD_LOGIC_VECTOR (6 DOWNTO 0);
  SIGNAL if_for_i_1_sva_2 : STD_LOGIC_VECTOR (5 DOWNTO 0);
  SIGNAL if_for_for_j_1_sva_2 : STD_LOGIC_VECTOR (5 DOWNTO 0);
  SIGNAL and_8_cse : STD_LOGIC;
  SIGNAL z_out : STD_LOGIC_VECTOR (6 DOWNTO 0);

  SIGNAL mux_4_nl : STD_LOGIC_VECTOR (5 DOWNTO 0);
  COMPONENT MazeArrayTester_core_fsm
    PORT(
      clk : IN STD_LOGIC;
      rst : IN STD_LOGIC;
      fsm_output : OUT STD_LOGIC_VECTOR (4 DOWNTO 0);
      st_main_tr0 : IN STD_LOGIC;
      st_if_for_for_1_tr0 : IN STD_LOGIC;
      st_if_for_tr0 : IN STD_LOGIC
    );
  END COMPONENT;
  SIGNAL MazeArrayTester_core_fsm_inst_fsm_output : STD_LOGIC_VECTOR (4 DOWNTO 0);
  SIGNAL MazeArrayTester_core_fsm_inst_st_if_for_for_1_tr0 : STD_LOGIC;
  SIGNAL MazeArrayTester_core_fsm_inst_st_if_for_tr0 : STD_LOGIC;

BEGIN
  -- Default Constant Signal Assignments

  -- Output Reader Assignments
  row_rsc_mgc_out_stdreg_d <= row_rsc_mgc_out_stdreg_d_drv;
  col_rsc_mgc_out_stdreg_d <= col_rsc_mgc_out_stdreg_d_drv;
  out_rsc_mgc_out_stdreg_d <= out_rsc_mgc_out_stdreg_d_drv;
  write_rsc_mgc_out_stdreg_d <= write_rsc_mgc_out_stdreg_d_drv;

  MazeArrayTester_core_fsm_inst : MazeArrayTester_core_fsm
    PORT MAP(
      clk => clk,
      rst => rst,
      fsm_output => MazeArrayTester_core_fsm_inst_fsm_output,
      st_main_tr0 => written_sva,
      st_if_for_for_1_tr0 => MazeArrayTester_core_fsm_inst_st_if_for_for_1_tr0,
      st_if_for_tr0 => MazeArrayTester_core_fsm_inst_st_if_for_tr0
    );
  fsm_output <= MazeArrayTester_core_fsm_inst_fsm_output;
  MazeArrayTester_core_fsm_inst_st_if_for_for_1_tr0 <= if_for_for_j_1_sva_1(6);
  MazeArrayTester_core_fsm_inst_st_if_for_tr0 <= z_out(6);

  and_8_cse <= (written_sva OR (NOT (fsm_output(1)))) AND ((NOT (fsm_output(4)))
      OR (z_out(6))) AND ((if_for_for_j_1_sva_1(6)) OR (NOT (fsm_output(3))));
  and_dcpl_4 <= (fsm_output(4)) AND (NOT (z_out(6)));
  and_dcpl_5 <= (NOT written_sva) AND (fsm_output(1));
  PROCESS (clk)
  BEGIN
    IF clk'EVENT AND ( clk = '1' ) THEN
      IF (rst = '1') THEN
        write_rsc_mgc_out_stdreg_d_drv <= '0';
        out_rsc_mgc_out_stdreg_d_drv <= STD_LOGIC_VECTOR'("0000");
        col_rsc_mgc_out_stdreg_d_drv <= STD_LOGIC_VECTOR'("000000");
        row_rsc_mgc_out_stdreg_d_drv <= STD_LOGIC_VECTOR'("000000");
        written_sva <= '0';
        if_for_i_1_sva_2 <= STD_LOGIC_VECTOR'("000000");
        if_for_for_j_1_sva_2 <= STD_LOGIC_VECTOR'("000000");
        if_for_for_j_1_sva_1 <= STD_LOGIC_VECTOR'("0000000");
      ELSE
        write_rsc_mgc_out_stdreg_d_drv <= (write_rsc_mgc_out_stdreg_d_drv AND (NOT((written_sva
            AND (fsm_output(1))) OR ((fsm_output(4)) AND (z_out(6)))))) OR (fsm_output(0));
        out_rsc_mgc_out_stdreg_d_drv <= MUX_v_4_2_2(out_rsc_mgc_out_stdreg_d_drv
            & (STD_LOGIC_VECTOR'("000") & TO_STDLOGICVECTOR((NOT((NOT((if_for_i_1_sva_2(5))
            AND (if_for_i_1_sva_2(4)) AND (if_for_i_1_sva_2(3)) AND (if_for_i_1_sva_2(2))
            AND (if_for_i_1_sva_2(1)) AND (if_for_i_1_sva_2(0)))) AND ((if_for_i_1_sva_2(5))
            OR (if_for_i_1_sva_2(4)) OR (if_for_i_1_sva_2(3)) OR (if_for_i_1_sva_2(2))
            OR (if_for_i_1_sva_2(1)) OR (if_for_i_1_sva_2(0))))) OR (NOT((NOT((if_for_for_j_1_sva_2(5))
            AND (if_for_for_j_1_sva_2(4)) AND (if_for_for_j_1_sva_2(3)) AND (if_for_for_j_1_sva_2(2))
            AND (if_for_for_j_1_sva_2(1)) AND (if_for_for_j_1_sva_2(0)))) AND ((if_for_for_j_1_sva_2(5))
            OR (if_for_for_j_1_sva_2(4)) OR (if_for_for_j_1_sva_2(3)) OR (if_for_for_j_1_sva_2(2))
            OR (if_for_for_j_1_sva_2(1)) OR (if_for_for_j_1_sva_2(0))))))), fsm_output(2));
        col_rsc_mgc_out_stdreg_d_drv <= (MUX_v_6_2_2((if_for_for_j_1_sva_1(5 DOWNTO
            0)) & col_rsc_mgc_out_stdreg_d_drv, and_8_cse)) AND STD_LOGIC_VECTOR(CONV_SIGNED(CONV_SIGNED(NOT(and_dcpl_5
            OR and_dcpl_4), 1),6));
        row_rsc_mgc_out_stdreg_d_drv <= (MUX1HOT_v_6_3_2(if_for_i_1_sva_2 & (z_out(5
            DOWNTO 0)) & row_rsc_mgc_out_stdreg_d_drv, STD_LOGIC_VECTOR'(((NOT (if_for_for_j_1_sva_1(6)))
            AND (fsm_output(3))) & and_dcpl_4 & and_8_cse))) AND STD_LOGIC_VECTOR(CONV_SIGNED(CONV_SIGNED(NOT
            and_dcpl_5, 1),6));
        written_sva <= (fsm_output(1)) OR (fsm_output(4));
        if_for_i_1_sva_2 <= (MUX_v_6_2_2((z_out(5 DOWNTO 0)) & if_for_i_1_sva_2,
            NOT((fsm_output(1)) OR (fsm_output(4))))) AND STD_LOGIC_VECTOR(CONV_SIGNED(CONV_SIGNED(NOT
            (fsm_output(1)), 1),6));
        if_for_for_j_1_sva_2 <= (if_for_for_j_1_sva_1(5 DOWNTO 0)) AND STD_LOGIC_VECTOR(CONV_SIGNED(CONV_SIGNED(fsm_output(3),
            1),6));
        if_for_for_j_1_sva_1 <= z_out;
      END IF;
    END IF;
  END PROCESS;
  mux_4_nl <= MUX_v_6_2_2(if_for_for_j_1_sva_2 & if_for_i_1_sva_2, fsm_output(4));
  z_out <= STD_LOGIC_VECTOR(CONV_UNSIGNED(CONV_UNSIGNED(UNSIGNED(mux_4_nl), 7) +
      UNSIGNED'("0000001"), 7));
END v2;

-- ------------------------------------------------------------------
--  Design Unit:    MazeArrayTester
--  Generated from file(s):
--    2) $PROJECT_HOME/../../src/MazeArrayTester.cpp
-- ------------------------------------------------------------------

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_ARITH.ALL;
LIBRARY mgc_hls;
USE mgc_hls.funcs.ALL;
USE work.MazeArrayTester_mux_pkg.ALL;


ENTITY MazeArrayTester IS
  PORT(
    row_rsc_z : OUT STD_LOGIC_VECTOR (5 DOWNTO 0);
    col_rsc_z : OUT STD_LOGIC_VECTOR (5 DOWNTO 0);
    out_rsc_z : OUT STD_LOGIC_VECTOR (3 DOWNTO 0);
    write_rsc_z : OUT STD_LOGIC;
    clk : IN STD_LOGIC;
    rst : IN STD_LOGIC
  );
END MazeArrayTester;

ARCHITECTURE v2 OF MazeArrayTester IS
  -- Default Constants

  -- Interconnect Declarations
  SIGNAL row_rsc_mgc_out_stdreg_d : STD_LOGIC_VECTOR (5 DOWNTO 0);
  SIGNAL col_rsc_mgc_out_stdreg_d : STD_LOGIC_VECTOR (5 DOWNTO 0);
  SIGNAL out_rsc_mgc_out_stdreg_d : STD_LOGIC_VECTOR (3 DOWNTO 0);
  SIGNAL write_rsc_mgc_out_stdreg_d : STD_LOGIC;

  SIGNAL row_rsc_mgc_out_stdreg_d_1 : STD_LOGIC_VECTOR (5 DOWNTO 0);
  SIGNAL row_rsc_mgc_out_stdreg_z : STD_LOGIC_VECTOR (5 DOWNTO 0);

  SIGNAL col_rsc_mgc_out_stdreg_d_1 : STD_LOGIC_VECTOR (5 DOWNTO 0);
  SIGNAL col_rsc_mgc_out_stdreg_z : STD_LOGIC_VECTOR (5 DOWNTO 0);

  SIGNAL out_rsc_mgc_out_stdreg_d_1 : STD_LOGIC_VECTOR (3 DOWNTO 0);
  SIGNAL out_rsc_mgc_out_stdreg_z : STD_LOGIC_VECTOR (3 DOWNTO 0);

  SIGNAL write_rsc_mgc_out_stdreg_d_1 : STD_LOGIC_VECTOR (0 DOWNTO 0);
  SIGNAL write_rsc_mgc_out_stdreg_z : STD_LOGIC_VECTOR (0 DOWNTO 0);

  COMPONENT MazeArrayTester_core
    PORT(
      clk : IN STD_LOGIC;
      rst : IN STD_LOGIC;
      row_rsc_mgc_out_stdreg_d : OUT STD_LOGIC_VECTOR (5 DOWNTO 0);
      col_rsc_mgc_out_stdreg_d : OUT STD_LOGIC_VECTOR (5 DOWNTO 0);
      out_rsc_mgc_out_stdreg_d : OUT STD_LOGIC_VECTOR (3 DOWNTO 0);
      write_rsc_mgc_out_stdreg_d : OUT STD_LOGIC
    );
  END COMPONENT;
  SIGNAL MazeArrayTester_core_inst_row_rsc_mgc_out_stdreg_d : STD_LOGIC_VECTOR (5
      DOWNTO 0);
  SIGNAL MazeArrayTester_core_inst_col_rsc_mgc_out_stdreg_d : STD_LOGIC_VECTOR (5
      DOWNTO 0);
  SIGNAL MazeArrayTester_core_inst_out_rsc_mgc_out_stdreg_d : STD_LOGIC_VECTOR (3
      DOWNTO 0);

BEGIN
  -- Default Constant Signal Assignments

  row_rsc_mgc_out_stdreg : mgc_hls.mgc_ioport_comps.mgc_out_stdreg
    GENERIC MAP(
      rscid => 1,
      width => 6
      )
    PORT MAP(
      d => row_rsc_mgc_out_stdreg_d_1,
      z => row_rsc_mgc_out_stdreg_z
    );
  row_rsc_mgc_out_stdreg_d_1 <= row_rsc_mgc_out_stdreg_d;
  row_rsc_z <= row_rsc_mgc_out_stdreg_z;

  col_rsc_mgc_out_stdreg : mgc_hls.mgc_ioport_comps.mgc_out_stdreg
    GENERIC MAP(
      rscid => 2,
      width => 6
      )
    PORT MAP(
      d => col_rsc_mgc_out_stdreg_d_1,
      z => col_rsc_mgc_out_stdreg_z
    );
  col_rsc_mgc_out_stdreg_d_1 <= col_rsc_mgc_out_stdreg_d;
  col_rsc_z <= col_rsc_mgc_out_stdreg_z;

  out_rsc_mgc_out_stdreg : mgc_hls.mgc_ioport_comps.mgc_out_stdreg
    GENERIC MAP(
      rscid => 3,
      width => 4
      )
    PORT MAP(
      d => out_rsc_mgc_out_stdreg_d_1,
      z => out_rsc_mgc_out_stdreg_z
    );
  out_rsc_mgc_out_stdreg_d_1 <= out_rsc_mgc_out_stdreg_d;
  out_rsc_z <= out_rsc_mgc_out_stdreg_z;

  write_rsc_mgc_out_stdreg : mgc_hls.mgc_ioport_comps.mgc_out_stdreg
    GENERIC MAP(
      rscid => 4,
      width => 1
      )
    PORT MAP(
      d => write_rsc_mgc_out_stdreg_d_1,
      z => write_rsc_mgc_out_stdreg_z
    );
  write_rsc_mgc_out_stdreg_d_1(0) <= write_rsc_mgc_out_stdreg_d;
  write_rsc_z <= write_rsc_mgc_out_stdreg_z(0);

  MazeArrayTester_core_inst : MazeArrayTester_core
    PORT MAP(
      clk => clk,
      rst => rst,
      row_rsc_mgc_out_stdreg_d => MazeArrayTester_core_inst_row_rsc_mgc_out_stdreg_d,
      col_rsc_mgc_out_stdreg_d => MazeArrayTester_core_inst_col_rsc_mgc_out_stdreg_d,
      out_rsc_mgc_out_stdreg_d => MazeArrayTester_core_inst_out_rsc_mgc_out_stdreg_d,
      write_rsc_mgc_out_stdreg_d => write_rsc_mgc_out_stdreg_d
    );
  row_rsc_mgc_out_stdreg_d <= MazeArrayTester_core_inst_row_rsc_mgc_out_stdreg_d;
  col_rsc_mgc_out_stdreg_d <= MazeArrayTester_core_inst_col_rsc_mgc_out_stdreg_d;
  out_rsc_mgc_out_stdreg_d <= MazeArrayTester_core_inst_out_rsc_mgc_out_stdreg_d;

END v2;



