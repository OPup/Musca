-- ----------------------------------------------------------------------
--  HLS HDL:        VHDL Netlister
--  HLS Version:    2011a.126 Production Release
--  HLS Date:       Wed Aug  8 00:52:07 PDT 2012
-- 
--  Generated by:   kjr115@EEWS104A-021
--  Generated date: Wed May 04 14:36:48 2016
-- ----------------------------------------------------------------------

-- 
-- ------------------------------------------------------------------
--  Design Unit:    MazeMemory_core_fsm
--  FSM Module
-- ------------------------------------------------------------------

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_ARITH.ALL;
LIBRARY mgc_hls;
USE mgc_hls.funcs.ALL;
USE mgc_hls.singleport_ram_be_pkg.ALL;
USE work.MazeMemory_mux_pkg.ALL;


ENTITY MazeMemory_core_fsm IS
  PORT(
    clk : IN STD_LOGIC;
    rst : IN STD_LOGIC;
    fsm_output : OUT STD_LOGIC_VECTOR (5 DOWNTO 0);
    st_maze_vinit_1_tr0 : IN STD_LOGIC
  );
END MazeMemory_core_fsm;

ARCHITECTURE v2 OF MazeMemory_core_fsm IS
  -- Default Constants

  -- FSM State Type Declaration for MazeMemory_core_fsm_1
  TYPE MazeMemory_core_fsm_1_ST IS (st_core_rlp, st_maze_vinit, st_maze_vinit_1,
      st_main, st_main_1, st_main_2);

  SIGNAL state_var : MazeMemory_core_fsm_1_ST;
  SIGNAL state_var_NS : MazeMemory_core_fsm_1_ST;

BEGIN
  -- Default Constant Signal Assignments

  MazeMemory_core_fsm_1 : PROCESS (st_maze_vinit_1_tr0, state_var)
  BEGIN
    CASE state_var IS
      WHEN st_core_rlp =>
        fsm_output <= STD_LOGIC_VECTOR'("000001");
        state_var_NS <= st_maze_vinit;
      WHEN st_maze_vinit =>
        fsm_output <= STD_LOGIC_VECTOR'("000010");
        state_var_NS <= st_maze_vinit_1;
      WHEN st_maze_vinit_1 =>
        fsm_output <= STD_LOGIC_VECTOR'("000100");
        IF ( st_maze_vinit_1_tr0 = '1' ) THEN
          state_var_NS <= st_maze_vinit;
        ELSE
          state_var_NS <= st_main;
        END IF;
      WHEN st_main =>
        fsm_output <= STD_LOGIC_VECTOR'("001000");
        state_var_NS <= st_main_1;
      WHEN st_main_1 =>
        fsm_output <= STD_LOGIC_VECTOR'("010000");
        state_var_NS <= st_main_2;
      WHEN st_main_2 =>
        fsm_output <= STD_LOGIC_VECTOR'("100000");
        state_var_NS <= st_main;
      WHEN OTHERS =>
        fsm_output <= "000000";
        state_var_NS <= st_core_rlp;
    END CASE;
  END PROCESS MazeMemory_core_fsm_1;

  MazeMemory_core_fsm_1_REG : PROCESS (clk)
  BEGIN
    IF clk'event AND ( clk = '1' ) THEN
      IF ( rst = '1' ) THEN
        state_var <= st_core_rlp;
      ELSE
        state_var <= state_var_NS;
      END IF;
    END IF;
  END PROCESS MazeMemory_core_fsm_1_REG;

END v2;

-- ------------------------------------------------------------------
--  Design Unit:    MazeMemory_core
-- ------------------------------------------------------------------

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_ARITH.ALL;
LIBRARY mgc_hls;
USE mgc_hls.funcs.ALL;
USE mgc_hls.singleport_ram_be_pkg.ALL;
USE work.MazeMemory_mux_pkg.ALL;


ENTITY MazeMemory_core IS
  PORT(
    clk : IN STD_LOGIC;
    rst : IN STD_LOGIC;
    row_rsc_mgc_in_wire_d : IN STD_LOGIC_VECTOR (4 DOWNTO 0);
    col_rsc_mgc_in_wire_d : IN STD_LOGIC_VECTOR (4 DOWNTO 0);
    val_rsc_mgc_in_wire_d : IN STD_LOGIC_VECTOR (3 DOWNTO 0);
    write_rsc_mgc_in_wire_d : IN STD_LOGIC;
    out_rsc_mgc_out_stdreg_d : OUT STD_LOGIC_VECTOR (3 DOWNTO 0);
    maze_rsc_singleport_data_in : OUT STD_LOGIC_VECTOR (3 DOWNTO 0);
    maze_rsc_singleport_addr : OUT STD_LOGIC_VECTOR (11 DOWNTO 0);
    maze_rsc_singleport_re : OUT STD_LOGIC;
    maze_rsc_singleport_we : OUT STD_LOGIC;
    maze_rsc_singleport_data_out : IN STD_LOGIC_VECTOR (3 DOWNTO 0)
  );
END MazeMemory_core;

ARCHITECTURE v2 OF MazeMemory_core IS
  -- Default Constants

  -- Output Reader Declarations
  SIGNAL out_rsc_mgc_out_stdreg_d_drv : STD_LOGIC_VECTOR (3 DOWNTO 0);

  -- Interconnect Declarations
  SIGNAL fsm_output : STD_LOGIC_VECTOR (5 DOWNTO 0);
  SIGNAL maze_vinit_ndx_1_sva : STD_LOGIC_VECTOR (11 DOWNTO 0);
  SIGNAL if_nor_itm : STD_LOGIC;
  SIGNAL if_acc_itm : STD_LOGIC_VECTOR (11 DOWNTO 0);
  SIGNAL io_read_write_rsc_d_svs_st : STD_LOGIC;
  SIGNAL maze_rsc_singleport_data_in_reg : STD_LOGIC_VECTOR (3 DOWNTO 0);
  SIGNAL and_6_rmff : STD_LOGIC_VECTOR (3 DOWNTO 0);

  COMPONENT MazeMemory_core_fsm
    PORT(
      clk : IN STD_LOGIC;
      rst : IN STD_LOGIC;
      fsm_output : OUT STD_LOGIC_VECTOR (5 DOWNTO 0);
      st_maze_vinit_1_tr0 : IN STD_LOGIC
    );
  END COMPONENT;
  SIGNAL MazeMemory_core_fsm_inst_fsm_output : STD_LOGIC_VECTOR (5 DOWNTO 0);
  SIGNAL MazeMemory_core_fsm_inst_st_maze_vinit_1_tr0 : STD_LOGIC;

BEGIN
  -- Default Constant Signal Assignments

  -- Output Reader Assignments
  out_rsc_mgc_out_stdreg_d <= out_rsc_mgc_out_stdreg_d_drv;

  MazeMemory_core_fsm_inst : MazeMemory_core_fsm
    PORT MAP(
      clk => clk,
      rst => rst,
      fsm_output => MazeMemory_core_fsm_inst_fsm_output,
      st_maze_vinit_1_tr0 => MazeMemory_core_fsm_inst_st_maze_vinit_1_tr0
    );
  fsm_output <= MazeMemory_core_fsm_inst_fsm_output;
  MazeMemory_core_fsm_inst_st_maze_vinit_1_tr0 <= NOT if_nor_itm;

  and_6_rmff <= val_rsc_mgc_in_wire_d AND STD_LOGIC_VECTOR(CONV_SIGNED(CONV_SIGNED(fsm_output(3),
      1),4));
  maze_rsc_singleport_data_in <= and_6_rmff;
  maze_rsc_singleport_addr <= MUX_v_12_2_2(maze_vinit_ndx_1_sva & (TO_STDLOGICVECTOR('0')
      & row_rsc_mgc_in_wire_d & TO_STDLOGICVECTOR('0') & col_rsc_mgc_in_wire_d),
      fsm_output(3));
  maze_rsc_singleport_re <= NOT((fsm_output(3)) AND (NOT write_rsc_mgc_in_wire_d));
  maze_rsc_singleport_we <= NOT(((fsm_output(3)) AND write_rsc_mgc_in_wire_d) OR
      (fsm_output(1)));
  PROCESS (clk)
  BEGIN
    IF clk'EVENT AND ( clk = '1' ) THEN
      IF (rst = '1') THEN
        maze_rsc_singleport_data_in_reg <= STD_LOGIC_VECTOR'("0000");
        out_rsc_mgc_out_stdreg_d_drv <= STD_LOGIC_VECTOR'("0000");
        maze_vinit_ndx_1_sva <= STD_LOGIC_VECTOR'("111111111111");
        if_nor_itm <= '0';
        if_acc_itm <= STD_LOGIC_VECTOR'("000000000000");
        io_read_write_rsc_d_svs_st <= '0';
      ELSE
        maze_rsc_singleport_data_in_reg <= and_6_rmff;
        out_rsc_mgc_out_stdreg_d_drv <= MUX1HOT_v_4_3_2(maze_rsc_singleport_data_in_reg
            & maze_rsc_singleport_data_out & out_rsc_mgc_out_stdreg_d_drv, STD_LOGIC_VECTOR'(((fsm_output(4))
            AND io_read_write_rsc_d_svs_st) & ((fsm_output(4)) AND (NOT io_read_write_rsc_d_svs_st))
            & (NOT (fsm_output(4)))));
        maze_vinit_ndx_1_sva <= MUX_v_12_2_2(maze_vinit_ndx_1_sva & if_acc_itm, fsm_output(2));
        if_nor_itm <= NOT((maze_vinit_ndx_1_sva(11)) OR (maze_vinit_ndx_1_sva(10))
            OR (maze_vinit_ndx_1_sva(9)) OR (maze_vinit_ndx_1_sva(8)) OR (maze_vinit_ndx_1_sva(7))
            OR (maze_vinit_ndx_1_sva(6)) OR (maze_vinit_ndx_1_sva(5)) OR (maze_vinit_ndx_1_sva(4))
            OR (maze_vinit_ndx_1_sva(3)) OR (maze_vinit_ndx_1_sva(2)) OR (maze_vinit_ndx_1_sva(1))
            OR (maze_vinit_ndx_1_sva(0)));
        if_acc_itm <= STD_LOGIC_VECTOR(CONV_UNSIGNED(UNSIGNED(maze_vinit_ndx_1_sva)
            + CONV_UNSIGNED(CONV_SIGNED('1', 1), 12), 12));
        io_read_write_rsc_d_svs_st <= write_rsc_mgc_in_wire_d;
      END IF;
    END IF;
  END PROCESS;
END v2;

-- ------------------------------------------------------------------
--  Design Unit:    MazeMemory
--  Generated from file(s):
--    2) $PROJECT_HOME/../../src/MazeArray.cpp
-- ------------------------------------------------------------------

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_ARITH.ALL;
LIBRARY mgc_hls;
USE mgc_hls.funcs.ALL;
USE mgc_hls.singleport_ram_be_pkg.ALL;
USE work.MazeMemory_mux_pkg.ALL;


ENTITY MazeMemory IS
  PORT(
    row_rsc_z : IN STD_LOGIC_VECTOR (4 DOWNTO 0);
    col_rsc_z : IN STD_LOGIC_VECTOR (4 DOWNTO 0);
    val_rsc_z : IN STD_LOGIC_VECTOR (3 DOWNTO 0);
    write_rsc_z : IN STD_LOGIC;
    out_rsc_z : OUT STD_LOGIC_VECTOR (3 DOWNTO 0);
    clk : IN STD_LOGIC;
    rst : IN STD_LOGIC
  );
END MazeMemory;

ARCHITECTURE v2 OF MazeMemory IS
  -- Default Constants
  SIGNAL PWR : STD_LOGIC;
  SIGNAL GND : STD_LOGIC;

  -- Interconnect Declarations
  SIGNAL row_rsc_mgc_in_wire_d : STD_LOGIC_VECTOR (4 DOWNTO 0);
  SIGNAL col_rsc_mgc_in_wire_d : STD_LOGIC_VECTOR (4 DOWNTO 0);
  SIGNAL val_rsc_mgc_in_wire_d : STD_LOGIC_VECTOR (3 DOWNTO 0);
  SIGNAL write_rsc_mgc_in_wire_d : STD_LOGIC;
  SIGNAL out_rsc_mgc_out_stdreg_d : STD_LOGIC_VECTOR (3 DOWNTO 0);
  SIGNAL maze_rsc_singleport_data_in : STD_LOGIC_VECTOR (3 DOWNTO 0);
  SIGNAL maze_rsc_singleport_addr : STD_LOGIC_VECTOR (11 DOWNTO 0);
  SIGNAL maze_rsc_singleport_re : STD_LOGIC;
  SIGNAL maze_rsc_singleport_we : STD_LOGIC;
  SIGNAL maze_rsc_singleport_data_out : STD_LOGIC_VECTOR (3 DOWNTO 0);

  SIGNAL row_rsc_mgc_in_wire_d_1 : STD_LOGIC_VECTOR (4 DOWNTO 0);
  SIGNAL row_rsc_mgc_in_wire_z : STD_LOGIC_VECTOR (4 DOWNTO 0);

  SIGNAL col_rsc_mgc_in_wire_d_1 : STD_LOGIC_VECTOR (4 DOWNTO 0);
  SIGNAL col_rsc_mgc_in_wire_z : STD_LOGIC_VECTOR (4 DOWNTO 0);

  SIGNAL val_rsc_mgc_in_wire_d_1 : STD_LOGIC_VECTOR (3 DOWNTO 0);
  SIGNAL val_rsc_mgc_in_wire_z : STD_LOGIC_VECTOR (3 DOWNTO 0);

  SIGNAL write_rsc_mgc_in_wire_d_1 : STD_LOGIC_VECTOR (0 DOWNTO 0);
  SIGNAL write_rsc_mgc_in_wire_z : STD_LOGIC_VECTOR (0 DOWNTO 0);

  SIGNAL out_rsc_mgc_out_stdreg_d_1 : STD_LOGIC_VECTOR (3 DOWNTO 0);
  SIGNAL out_rsc_mgc_out_stdreg_z : STD_LOGIC_VECTOR (3 DOWNTO 0);

  SIGNAL maze_rsc_singleport_data_in_1 : STD_LOGIC_VECTOR (3 DOWNTO 0);
  SIGNAL maze_rsc_singleport_addr_1 : STD_LOGIC_VECTOR (11 DOWNTO 0);
  SIGNAL maze_rsc_singleport_re_1 : STD_LOGIC_VECTOR (0 DOWNTO 0);
  SIGNAL maze_rsc_singleport_we_1 : STD_LOGIC_VECTOR (0 DOWNTO 0);
  SIGNAL maze_rsc_singleport_data_out_1 : STD_LOGIC_VECTOR (3 DOWNTO 0);

  COMPONENT MazeMemory_core
    PORT(
      clk : IN STD_LOGIC;
      rst : IN STD_LOGIC;
      row_rsc_mgc_in_wire_d : IN STD_LOGIC_VECTOR (4 DOWNTO 0);
      col_rsc_mgc_in_wire_d : IN STD_LOGIC_VECTOR (4 DOWNTO 0);
      val_rsc_mgc_in_wire_d : IN STD_LOGIC_VECTOR (3 DOWNTO 0);
      write_rsc_mgc_in_wire_d : IN STD_LOGIC;
      out_rsc_mgc_out_stdreg_d : OUT STD_LOGIC_VECTOR (3 DOWNTO 0);
      maze_rsc_singleport_data_in : OUT STD_LOGIC_VECTOR (3 DOWNTO 0);
      maze_rsc_singleport_addr : OUT STD_LOGIC_VECTOR (11 DOWNTO 0);
      maze_rsc_singleport_re : OUT STD_LOGIC;
      maze_rsc_singleport_we : OUT STD_LOGIC;
      maze_rsc_singleport_data_out : IN STD_LOGIC_VECTOR (3 DOWNTO 0)
    );
  END COMPONENT;
  SIGNAL MazeMemory_core_inst_row_rsc_mgc_in_wire_d : STD_LOGIC_VECTOR (4 DOWNTO
      0);
  SIGNAL MazeMemory_core_inst_col_rsc_mgc_in_wire_d : STD_LOGIC_VECTOR (4 DOWNTO
      0);
  SIGNAL MazeMemory_core_inst_val_rsc_mgc_in_wire_d : STD_LOGIC_VECTOR (3 DOWNTO
      0);
  SIGNAL MazeMemory_core_inst_out_rsc_mgc_out_stdreg_d : STD_LOGIC_VECTOR (3 DOWNTO
      0);
  SIGNAL MazeMemory_core_inst_maze_rsc_singleport_data_in : STD_LOGIC_VECTOR (3 DOWNTO
      0);
  SIGNAL MazeMemory_core_inst_maze_rsc_singleport_addr : STD_LOGIC_VECTOR (11 DOWNTO
      0);
  SIGNAL MazeMemory_core_inst_maze_rsc_singleport_data_out : STD_LOGIC_VECTOR (3
      DOWNTO 0);

BEGIN
  -- Default Constant Signal Assignments
  PWR <= '1';
  GND <= '0';

  row_rsc_mgc_in_wire : mgc_hls.mgc_ioport_comps.mgc_in_wire
    GENERIC MAP(
      rscid => 1,
      width => 5
      )
    PORT MAP(
      d => row_rsc_mgc_in_wire_d_1,
      z => row_rsc_mgc_in_wire_z
    );
  row_rsc_mgc_in_wire_d <= row_rsc_mgc_in_wire_d_1;
  row_rsc_mgc_in_wire_z <= row_rsc_z;

  col_rsc_mgc_in_wire : mgc_hls.mgc_ioport_comps.mgc_in_wire
    GENERIC MAP(
      rscid => 2,
      width => 5
      )
    PORT MAP(
      d => col_rsc_mgc_in_wire_d_1,
      z => col_rsc_mgc_in_wire_z
    );
  col_rsc_mgc_in_wire_d <= col_rsc_mgc_in_wire_d_1;
  col_rsc_mgc_in_wire_z <= col_rsc_z;

  val_rsc_mgc_in_wire : mgc_hls.mgc_ioport_comps.mgc_in_wire
    GENERIC MAP(
      rscid => 3,
      width => 4
      )
    PORT MAP(
      d => val_rsc_mgc_in_wire_d_1,
      z => val_rsc_mgc_in_wire_z
    );
  val_rsc_mgc_in_wire_d <= val_rsc_mgc_in_wire_d_1;
  val_rsc_mgc_in_wire_z <= val_rsc_z;

  write_rsc_mgc_in_wire : mgc_hls.mgc_ioport_comps.mgc_in_wire
    GENERIC MAP(
      rscid => 4,
      width => 1
      )
    PORT MAP(
      d => write_rsc_mgc_in_wire_d_1,
      z => write_rsc_mgc_in_wire_z
    );
  write_rsc_mgc_in_wire_d <= write_rsc_mgc_in_wire_d_1(0);
  write_rsc_mgc_in_wire_z(0) <= write_rsc_z;

  out_rsc_mgc_out_stdreg : mgc_hls.mgc_ioport_comps.mgc_out_stdreg
    GENERIC MAP(
      rscid => 5,
      width => 4
      )
    PORT MAP(
      d => out_rsc_mgc_out_stdreg_d_1,
      z => out_rsc_mgc_out_stdreg_z
    );
  out_rsc_mgc_out_stdreg_d_1 <= out_rsc_mgc_out_stdreg_d;
  out_rsc_z <= out_rsc_mgc_out_stdreg_z;

  maze_rsc_singleport : mgc_hls.singleport_ram_be_pkg.singleport_ram_be
    GENERIC MAP(
      ram_id => 6,
      words => 4096,
      width => 4,
      addr_width => 12,
      a_reset_active => 0,
      s_reset_active => 1,
      enable_active => 0,
      re_active => 0,
      we_active => 0,
      num_byte_enables => 1,
      clock_edge => 1,
      num_input_registers => 1,
      num_output_registers => 0,
      no_of_singleport_readwrite_port => 1
      )
    PORT MAP(
      data_in => maze_rsc_singleport_data_in_1,
      addr => maze_rsc_singleport_addr_1,
      re => maze_rsc_singleport_re_1,
      we => maze_rsc_singleport_we_1,
      data_out => maze_rsc_singleport_data_out_1,
      clk => clk,
      a_rst => PWR,
      s_rst => rst,
      en => GND
    );
  maze_rsc_singleport_data_in_1 <= maze_rsc_singleport_data_in;
  maze_rsc_singleport_addr_1 <= maze_rsc_singleport_addr;
  maze_rsc_singleport_re_1(0) <= maze_rsc_singleport_re;
  maze_rsc_singleport_we_1(0) <= maze_rsc_singleport_we;
  maze_rsc_singleport_data_out <= maze_rsc_singleport_data_out_1;

  MazeMemory_core_inst : MazeMemory_core
    PORT MAP(
      clk => clk,
      rst => rst,
      row_rsc_mgc_in_wire_d => MazeMemory_core_inst_row_rsc_mgc_in_wire_d,
      col_rsc_mgc_in_wire_d => MazeMemory_core_inst_col_rsc_mgc_in_wire_d,
      val_rsc_mgc_in_wire_d => MazeMemory_core_inst_val_rsc_mgc_in_wire_d,
      write_rsc_mgc_in_wire_d => write_rsc_mgc_in_wire_d,
      out_rsc_mgc_out_stdreg_d => MazeMemory_core_inst_out_rsc_mgc_out_stdreg_d,
      maze_rsc_singleport_data_in => MazeMemory_core_inst_maze_rsc_singleport_data_in,
      maze_rsc_singleport_addr => MazeMemory_core_inst_maze_rsc_singleport_addr,
      maze_rsc_singleport_re => maze_rsc_singleport_re,
      maze_rsc_singleport_we => maze_rsc_singleport_we,
      maze_rsc_singleport_data_out => MazeMemory_core_inst_maze_rsc_singleport_data_out
    );
  MazeMemory_core_inst_row_rsc_mgc_in_wire_d <= row_rsc_mgc_in_wire_d;
  MazeMemory_core_inst_col_rsc_mgc_in_wire_d <= col_rsc_mgc_in_wire_d;
  MazeMemory_core_inst_val_rsc_mgc_in_wire_d <= val_rsc_mgc_in_wire_d;
  out_rsc_mgc_out_stdreg_d <= MazeMemory_core_inst_out_rsc_mgc_out_stdreg_d;
  maze_rsc_singleport_data_in <= MazeMemory_core_inst_maze_rsc_singleport_data_in;
  maze_rsc_singleport_addr <= MazeMemory_core_inst_maze_rsc_singleport_addr;
  MazeMemory_core_inst_maze_rsc_singleport_data_out <= maze_rsc_singleport_data_out;

END v2;



